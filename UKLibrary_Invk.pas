unit UKLibrary_Invk;

// ----------------------------------------------------------------------
//  This file was automatically generated by Remoting SDK from a
//  RODL file downloaded from a server or associated with this project.
//
//  Do not modify this file manually, or your changes will be lost when
//  it is regenerated the next time you update your RODL.
// ----------------------------------------------------------------------

{$I RemObjects.inc}

interface

uses
  {$IFDEF DELPHIXE2UP}System.SysUtils{$ELSE}SysUtils{$ENDIF},
  {$IFDEF DELPHIXE2UP}System.Classes{$ELSE}Classes{$ENDIF},
  uROEncoding,
  uROXMLIntf,
  uROServer,
  uROServerIntf,
  uROClasses,
  uROTypes,
  uROClientIntf,
  UKLibrary_Intf;

type
  { Forward declarations }
  TLogonService_Invoker = class;
  TAppService_Invoker = class;

  TLogonService_Invoker = class(TROInvoker)
  public
    constructor Create; override;
  published
    procedure Invoke__ClientConn(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
  end;

  TAppService_Invoker = class(TROInvoker)
  public
    constructor Create; override;
  published
    procedure Invoke_GetSessionID(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
  end;

implementation

uses
  uROEventRepository,
  uRORes,
  uROClient;

constructor TLogonService_Invoker.Create;
begin
  inherited Create();
  FAbstract := false;
end;

procedure TLogonService_Invoker.Invoke__ClientConn(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_ClientInfo: IXmlNode;
  l_ServerInfo: IXmlNode;
  lResult: Boolean;
  __lintf: UKLibrary_Intf.ILogonService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  try
    if not Supports(__Instance, ILogonService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TLogonService_Invoker.Invoke__ClientConn: __Instance does not support LogonService interface');
    end;

    __Message.Read('ClientInfo', System.TypeInfo(IXmlNode), l_ClientInfo, []);

    lResult := __lintf._ClientConn(l_ClientInfo, l_ServerInfo);

    __Message.InitializeResponseMessage(__Transport, 'UKLibrary', 'LogonService', '_ClientConnResponse');
    __Message.Write('Result', System.TypeInfo(Boolean), lResult, []);
    __Message.Write('ServerInfo', System.TypeInfo(IXmlNode), l_ServerInfo, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
  end;
end;

constructor TAppService_Invoker.Create;
begin
  inherited Create();
  FAbstract := false;
end;

procedure TAppService_Invoker.Invoke_GetSessionID(const __Instance: IInterface; const __Message: IROMessage; const __Transport: IROTransport; out __oResponseOptions: TROResponseOptions);
var
  l_NewParam: UnicodeString;
  lResult: UnicodeString;
  __lintf: UKLibrary_Intf.IAppService;
begin
  CheckRoles(__Instance, GetDefaultServiceRoles());
  try
    if not Supports(__Instance, IAppService, __lintf) then begin
      raise EIntfCastError.Create('Critical error in TAppService_Invoker.Invoke_GetSessionID: __Instance does not support AppService interface');
    end;

    __Message.Read('NewParam', System.TypeInfo(UnicodeString), l_NewParam, []);

    lResult := __lintf.GetSessionID(l_NewParam);

    __Message.InitializeResponseMessage(__Transport, 'UKLibrary', 'AppService', 'GetSessionIDResponse');
    __Message.Write('Result', System.TypeInfo(UnicodeString), lResult, []);
    __Message.Finalize();
    __Message.UnsetAttributes(__Transport);

  finally
    __lintf := nil;
  end;
end;

initialization
finalization
end.

